# 1부 3장. 단위테스트의 구조

1. 단위테스트 구조
2. 좋은 단위테스트 명명법
3. 매개변수화된 테스트 작성
4. Fluent Assertions


## 1. 단위테스트를 구성하는 방법


### AAA 패턴 사용

각 테스트를 준비, 실행, 검증 세 부분으로 나눈다. (Given-When-Then 패턴과 동일)   
- 준비: SUT(System Under Test)와 해당 의존성을 원하는 상태로 만든다.
- 실행: SUT에서 메소드를 호출, 준비된 의존성을 전달, 출력값 캡처한다.
- 검증: 결과 검증. 반환값이나 SUT와 협력자의 최종 상태, SUT가 협력자에 호출한 메소드 등 검증.

TDD를 실천한다면, 준비 단계는 건너뛰고 검증 단계부터 작성.   
테스트 전에 제품 코드를 작성한다면, 준비 구절부터 시작.   

```java
public class Calculator {
    public double sum(double first, double second) {
		return first + second;
    }
} 


public class CalculatorTest {
	
	public void Sum_of_two_numbers() { // 단위테스트이름
		// 준비
        double first = 10;
		double second = 20;
		var calculator = new Calculator();
		
        // 실행
        double result = calculator.sum(first, second);
        
        // 검증
        Assert.equals(30, result);
    }
	
}
```


### 여러 개의 준비, 실행, 검증 구절 피하기

[ 테스트 준비 -> 실행 -> 검증 -> 좀 더 실행 -> 다시 검증 ] 이런 구조는 단위테스트가 아니라 통합테스트이다.   
이러한 테스트 구조는 피하는 것이 좋다. 각 동작을 고유의 테스트로 도출해라.


### 테스트 내 if 문 피하기

단위테스트든 통합테스트든 테스트는 분기가 없는 간단한 일련의 단계로 작성.   
if문은 테스트가 한 번에 너무 많은 것을 검증한다는 표시다. 이런 테스트는 반드시 여러 테스트로 나눠야 한다.


### 준비, 실행, 검증 각 구절의 크기는?

1. 준비 구절이 일반적으로 가장 크다. 그러나 (실행 구절 + 검증 구절)보다 훨씬 크면, 같은 테스트 클래스 내 비공개 메소드 또는 별도의 팩토리 클래스로 도출해라.
   - Object mother, Test data builder 패턴 참고.
2. 실행 구절이 두 줄 이상인 경우를 경계해라.
    ```java
    public class PurchaseTest {
        
        // (Good) 한 줄로 된 실행 구절
        public void Purchase_succeeds_when_enough_inventory() {
            // 준비
            var store = new Store();
            store.AddInventory(Product.Shampoo, 10);
            var customer = new Customer();
    
            // 실행
            bool success = customer.Purchase(store, Product.Shampoo, 5);
            
            // 검증
            Assert.True(success);
            Assert.Equal(5, store.GetInventory(Product.Shampoo));
        }
    
        // (Bad) 두 줄로 된 실행 구절
        public void Purchase_succeeds_when_enough_inventory() {
            // 준비
            var store = new Store();
            store.AddInventory(Product.Shampoo, 10);
            var customer = new Customer();
            
            // 실행
            bool success = customer.Purchase(store, Product.Shampoo, 5);
            store.RemoveInventory(success, Product.Shampoo, 5);
            
            // 검증
            Assert.True(success);
            Assert.Equal(5, store.GetInventory(Product.Shampoo));
        }
    }
    ```
   - 두 줄의 문제점: 단일 작업을 수행하는 데 두 개의 메소드 호출이 필요하다는 것.
     - 클라이언트 코드가 두번째 메소드를 호출하지 않으면? 고객은 제품을 얻지만 재고 수량이 줄어들지 않는 크리티컬한 오류 발생 가능.
     - Purchase 메소드의 한 부분으로 재고 제거까지 해야한다.
   - 코드 "encapsulation" 위반. 
3. 검증 구절이 너무 커지는 것을 경계하자
   - SUT에서 반환된 객체 내에서 모든 속성을 검증하는 대신 객체 클래스내에 적절한 동등 멤버 (Equals)를 정의하는 것이 좋다 (`equals`, `==`로 동등 비교가 가능한 멤버 메서드, 연산자 통칭)

4. 단위테스트에는 종료 구절이 필요 없다. 종료는 통합테스트의 영역
   - 준비, 실행, 검증 이후 네 번쨰 구절로 종료 구절을 따로 만들기도 함.
     - 테스트에 의해 작성된 파일을 지우거나 DB 연결을 종료 등
   - 그러나 단위테스트는 프로세스 외부에 종속적이지 않으므로 처리해야 할 사이드 이펙트를 남기지 않음. => 종료 구절 불필요

5. 테스트 대상 시스템 구별하기
   - 테스트 대상 시스템과 의존성을 구별해야 한다.
   - 테스트 대상의 클래스명을 sut로 하면 구분이 쉬움.
    ```java
    public class PurchaseTest {
        void sum() {
            // 준비
            double first = 10;
            double second = 20;
            var sut = new Calculator();
    
            // 실행
            double result = sut.sum(first, second);
            
            // 검증
            ...
        }
    }
    ```

### 테스트 간 테스트 픽스처 재사용
> 테스트 픽스처란?   
> 테스트 실행 대상 객체. SUT로 전달되는 인수다. DB에 있는 데이터나 디스크에 있는 파일일 수 있다.    
> 각 테스트 실행 전에 알려진 고정 상태로 유지하기 때문에 동일한 결과를 생성한다. 고정 상태를 유지하여서 픽스처라는 단어가 나왔다.    

#### 테스트 픽스처를 재사용하는 방법

1. (BAD) 생성자에서 초기화
```java
public class CustomerTests {
    private Store _store; // 공유 상태 (BAD)
    private Customer _sut; // 공유 상태 (BAD)

	public CustomerTests() {
		_store = new Store();
		_store.addInventory(Product.Shampoo, 10); 
		_sut = new customer();
	}
	
    public void Purchase_succeeds_when_enough_inventory() {
		bool success = _sut.purchase(_store, Product.Shampoo, 5);

		Assert.True(success); 
		Assert.Equal(5, _store.getInventory(Product.Shampoo));
	}
}
```
   - 장점: 테스트 코드의 양을 크게 줄일 수 있다.
   - 단점1. 테스트 간 결합도가 높아짐
     - `_store.AddInventory(Product.Shampoo, 10);` 을 `_store.AddInventory(Product.Shampoo, 15);`로 바꾸면 다른 테스트가 실패한다.
     - **테스트클래스에 `private Store _store;`, `private Customer _sut;`와 같은 공유 상태를 두면 안된다.**
   - 단점2. 테스트 가독성이 떨어짐
     - 테스트 메소드 하나만 보고는 전체 로직을 알 수 없다.


2. 테스트 클래스의 비공개 팩토리 메서드로 테스트 픽스처를 재사용하기.

```java

public class CustomerTests {

	public void Purchase_succeeds_when_enough_inventory() {

		Store store = createStoreWithInventory(Product.Shampoo, 5);
        Customer sut = createCustomer();

		bool success = _sut.purchase(_store, Product.Shampoo, 5);

		Assert.True(success);
		Assert.Equal(5, _store.getInventory(Product.Shampoo));
	}

	private Store createStoreWithInventory(Product product, int quantity) {
		Store store = new Store();
		store.addInventory(product, quantity);
		return store;
	}

	private static Customer createCustomer() {
		return new Customer();
	}
}
```
  - 장점: 테스트 코드를 짧게 유지 가능. 비공개 메소드를 충분히 일반화하면 테스트가 서로 결합되지 않음. 

### 단위테스트 명명 지침
1. 엄격한 명명 정책을 따르지 말고, 쉬운 영어로 간결하게, 비개발자에세 설명하는 것처럼 작성.
   - (GOOD) `public void Sum_of_two_numbers()`
   - (BAD) `public void Sum_of_TwoNumbers_ReturnsSum()`
   - 잘못된 날짜의 배송을 올바르게 식별하는지 검증할 때,
   - (BAD) `public void IsDeliveryValid_InvalidDate_ReturnsFalse()` - 가독성X, 쉽지X, 프로그래머가 아닌 사람들에게 납득X
   - (BAD) `public void Delivery_with_invalid_date_should_be_considered_invalid()` - 배송 날짜가 invalid하다는게 무슨 뜻인지?
   - (BAD) `public void Delivery_with_past_date_should_be_considered_invalid()` - 너무 장황. considered 제거
   - (BAD) `public void Delivery_with_past_date_should_be_invalid()` - should be는 안티패턴
   - (BAD) `public void Delivery_with_past_date_is_invalid()` - 문법을 지켜야 함
   - (GOOD) `public void Delivery_with_a_past_date_is_invalid()`
2. 단어를 _로 구분해라.
3. 테스트 클래스이름은 보통 `{클래스명}Tests` 패턴을 사용하여 동작 단위로 검증할 수 있는 진입점 제공. 
   - 단, 단위테스트의 단위는 동작의 단위이지 클래스의 단위가 아니기 때문에 해당 테스트 클래스만 검증하는 것으로 제한하는 것은 아님. 
4. 테스트 이름에 SUT의 메서드 이름을 포함하지 마라. 구현 세부 사항과 테스트간의 결합도가 높아져서 메서드명이 변경되면 테스트 이름도 바꿔야 함.
