# 1부 3장. 단위테스트란 구조

1. 단위테스트 구조
2. 좋은 단위테스트 명명법
3. 매개변수화된 테스트 작성
4. Fluent Assertions


## 1. 단위테스트를 구성하는 방법


### AAA 패턴 사용

각 테스트를 준비, 실행, 검증 세 부분으로 나눈다. (Given-When-Then 패턴과 동일)   
- 준비: SUT와 해당 의존성을 원하는 상태로 만든다.
- 실행: SUT에서 메소드를 호출, 준비된 의존성을 전달, 출력값 캡처한다.
- 검증: 결과 검증. 반환값이나 SUT와 협력자의 최종 상태, SUT가 협력자에 호출한 메소드 등 검증.

TDD를 실천한다면, 준비 단계는 건너뛰고 검증 단계부터 작성.   
테스트 전에 제품 코드를 작성한다면, 준비 구절부터 시작.   

```java
public class Calculator {
    public double sum(double first, double second) {
		return first + second;
    }
} 


public class CalculatorTest {
	
	public void Sum_of_two_numbers() { // 단위테스트이름
		// 준비
        double first = 10;
		double second = 20;
		var calculator = new Calculator();
		
        // 실행
        double result = calculator.sum(first, second);
        
        // 검증
        Assert.equals(30, result);
    }
	
}
```


### 여러 개의 준비, 실행, 검증 구절 피하기

[ 테스트 준비 -> 실행 -> 검증 -> 좀 더 실행 -> 다시 검증 ] 이런 구조는 단위테스트가 아니라 통합테스트이다.   
이러한 테스트 구조는 피하는 것이 좋다. 각 동작을 고유의 테스트로 도출해라.


### 테스트 내 if 문 피하기

단위테스트든 통합테스트든 테스트는 분기가 없는 간단한 일련의 단계로 작성.   
if문은 테스트가 한 번에 너무 많은 것을 검증한다는 표시다. 이런 테스트는 반드시 여러 테스트로 나눠야 한다.


### 준비, 실행, 검증 각 구절의 크기는?

1. 준비 구절이 일반적으로 가장 크다. 그러나 (실행 구절 + 검증 구절)보다 훨씬 크면, 같은 테스트 클래스 내 비공개 메소드 또는 별도의 팩토리 클래스로 도출해라.
   - Object mother, Test data builder 패턴 참고.
2. 실행 구절이 한 줄 이상인 경우를 경계해라.
    ```java
    public class PurchaseTest {
        
        // (Good) 한 줄로 된 실행 구절
        public void Purchase_succeeds_when_enough_inventory() {
            // 준비
            var store = new Store();
            store.AddInventory(Product.Shampoo, 10);
            var customer = new Customer();
    
            // 실행
            bool success = customer.Purchase(store, Product.Shampoo, 5);
            
            // 검증
            Assert.True(success);
            Assert.Equal(5, store.GetInventory(Product.Shampoo));
        }
    
        // (Bad) 두 줄로 된 실행 구절
        public void Purchase_succeeds_when_enough_inventory() {
            // 준비
            var store = new Store();
            store.AddInventory(Product.Shampoo, 10);
            var customer = new Customer();
            
            // 실행
            bool success = customer.Purchase(store, Product.Shampoo, 5);
            store.RemoveInventory(success, Product.Shampoo, 5);
            
            // 검증
            Assert.True(success);
            Assert.Equal(5, store.GetInventory(Product.Shampoo));
        }
    }
    ```
   - 두 줄의 문제점: 단일 작업을 수행하는 데 두 개의 메소드 호출이 필요하다는 것.
     - 클라이언트 코드가 두번째 메소드를 호출하지 않으면? 고객은 제품을 얻지만 재고 수량이 줄어들지 않는 크리티컬한 오류 발생 가능.
     - Purchase 메소드의 한 부분으로 재고 제거까지 해야한다.
   - 코드 "encapsulation" 위반. 

