# 1부 2장. 단위테스트란 무엇인가

1. 단위테스트란
2. 공유 의존성, 비공개 의존성, 휘발성 의존성 간의 차이점
3. 단위테스트의 두 분파
4. 단위테스트, 통합테스트, E2E 테스트의 차이점

## 단위테스트의 정의
1. 작은 코드 조각을 검증하고
2. 빠르게 수행하고
3. 격리된 방식으로 처리하는 자동화된 테스트.
    - 격리 문제가 고전파와 런던파를 구분할 수 있는 근원적 차이.
    - 런던파: 테스트 대상 시스템에서 의존성을 격리하는 것
    - 고전파: 단위테스트끼리 격리하는 것. "다른 테스트와 별도로 처리한다."

### 코드 조각을 격리된 방식으로 검증한다는 의미는?

#### 1. 런던파
- 격리 주체: 테스트 대상 시스템(SUT, System Under Test)을 협력자(collaborator, 의존성)와 격리
- 단위의 크기: 단일 클래스
- Test double 사용 대상: 불변 의존성 외 모든 의존성
  > ##### "Test double"이란?    
  > xUnit Test Patterns의 저자인 제라드 메스자로스(Gerard Meszaros)가 만든 용어로,    
  > 테스트를 진행하기 어려운 경우 이를 대신해 테스트를 진행할 수 있도록 만들어주는 **가짜 의존성 객체**를 말한다.    
  > 예를 들어 우리가 데이터베이스로부터 조회한 값을 연산하는 로직을 구현했다고 하자.    
  > 해당 로직을 테스트하기 위해선 항상 데이터베이스의 영향을 받을 것이고, 이는 데이터베이스의 상태에 따라 다른 결과를 유발할 수도 있다.    
  > 이렇게 테스트하려는 객체와 연관된 객체를 사용하기가 어렵고 모호할 때 대신해 줄 수 있는 객체를 테스트 더블이라 한다.    
  > 자바의 Mockito 같은 것.    

- 장점
  1. 테스트가 실패하면 코드베이스의 어느 부분이 고장났는지 확실히 알 수 있다.
  2. 객체 그래프를 분할할 수 있다. 클래스의 직접적인 의존성을 대체할 수 있다.
  3. 한 번에 한 클래스만 테스트하고, 의존성(협력자)은 다 test double로 하면, 전체 단위 테스트 스위트를 간단한 구조로 설계할 수 있다.
     - (예시)
     - 클래스 1 테스트 -> 클래스 1
     - 클래스 2 테스트 -> 클래스 2
     - ...

- 테스트 코드 예시: test double로 협력자(의존성)를 대체하여 테스트.   
  Customer만 실제 인스턴스를 사용하고, 협력자인 Store는 test double로 교체한다.
```c#
public void Purchase_succeeds_when_enough_inventory()
    var storeMock = new Mock<IStore>(); // Store 구체 클래스가 아닌 Store의 인터페이스 IStore로부터 Mock 생성. 구체 클래스에서 Mock 생성하는 것은 안티 패턴.
    storeMock
        .Setup(x => x.HasEnoughInventory(Product.Shampoo, 5)) // store에 상품 재고를 추가하지 않고, HasEnoughInventory 메소드에 어떻게 응답할 것인지 mocking 
        .Returns(true);
    var customer = new Customer();
    
    // 실행
    bool success = customer.Purchase(
        storeMock.Object, Product.Shampoo, 5);
    
    // 검증
    Assert.True(success);
    storeMock.Verify(
        x => x.RemoveInventory(Product.Shampoo, 5), // store의 상태를 확인하는 것이 아니라, customer과 store의 상호작용(메소드 호출 여부, 횟수)를 검증한다. 
        Times.Once);
}

public void Purchase_fails_when_not_enough_inventory()
{
    // 준비
    var storeMock = new Mock<IStore>();
    storeMock
        .Setup(x => x.HasEnoughInventory(Product.Shampoo, 5))
        .Returns(false);
    var customer = new Customer();
    
    // 실행
    bool success = customer.Purchase(
        storeMock.Object, Product.Shampoo, 5);
    
    // 검증
    Assert.False(success);
    storeMock.Verify(
        X => X. RemoveInventory(Product. Shampoo, 5),
        Times.Never);
}
```


#### 2. 고전파

- 격리 주체: 단위테스트 간의 격리
- 단위의 크기: 코드 단위가 아닌 동작 단위. 단일 클래스 또는 여러 클래스의 세트가 될 수 있다.
- Test double 사용 대상: 공유 의존성
   - 데이터베이스, 파일 시스템 등 테스트 간 간섭을 줄 수 있는 항목에 대해서만 test double을 사용한다.   
   - 공유 의존성을 대체하면 각각의 테스트를 격리하고, 테스트 실행 속도를 높일 수 있다. 한 번에 여러 테스트를 수행할 수도 있다.
   > (참고) 의존성의 종류
   > - 공유 의존성: 테스트 간에 공유되고 서로의 결과에 영향을 미칠 수 있는 의존성. Test double 사용 필요. (예시) 정적 가변 필드, 데이터베이스.
   > - 비공개 의존성: 공유하지 않는 의존성. Test double 사용 안함. (예시) 설정 클래스.
   > - 프로세스 외부 의존성: 애플리케이션 실행 외부에서 실행되는 의존성. (예시) 데이터베이스.     
   >    단, 테스트 시마다 도커로 새로 데이터베이스를 띄우는 경우, 읽기 전용 API 호출하는 등은 프로세스 외부 의존성은 맞으나 공유 의존성은 아님.

<img src="../static/1-2_mock.jpeg" width=500>

- 테스트 코드 예시: 협력자를 test double로 대체하지 않고 실제 운영용 인스턴스 사용.   
  Store과 Customer 둘 다 검증 가능하나, Customer가 아닌 Store에 문제가 생겨도 테스트 실패한다. 

```c#
public void Purchase_succeeds_when_enough_inventory()
{
    // 준비
    var store = new Store();
    store.AddInventory(Product.Shampoo, 10);
    var customer = new Customer();

    // 실행
    bool success = customer.Purchase(store, Product.Shampoo, 5);
    
    // 검증
    Assert.True(success);
    Assert.Equal(5, store.GetInventory(Product.Shampoo));
}

public void Purchase_fails_when_not_enough_inventory()
{
    // 준비
    var store = new Store();
    store.AddInventory(Product.Shampoo, 10);
    var customer =  new Customer();

    // 실행
    bool success = customer.Purchase(store, Product.Shampoo, 15);
    
    // 검증
    Assert.False(success);
    Assert.Equal(10, store.GetInventory(Product .Shampoo));
}
```
- 고전파에서 test double로 교체하는 의존성
  - 공유 의존성
  - 공유 의존성은 아닌 프로세스 외부 의존성 중, 속도가 느린 의존성. (예: 외부 API 호출 등)

### 고전파와 런던파 사이의 다른 차이점 (2.3.4)
- TDD를 통한 시스템 설계 방식 (모르겠음)
  - 런던파: 하향식 TDD. ???
  - 고전파: 도메인 모델을 시작으로 쭉 개발하고 테스트 작성?
- 과도한 명세 over specification 문제: ? 테스트가 SUT의 구현 세부 사항에 결합되는 것.

## 통합테스트
- 통합테스트의 정의
    - 런던파: 실제 협력자 객체를 사용하는 모든 테스트. 고전파의 단위테스트가 런던파에서는 통합 테스트이다.
    - 고전파
      - 고전파에서 통합테스트란?
        - 공유 의존성(ex. 데이터베이스)에 접근하는 테스트.
        - 프로세스 외부 의존성에 접근하는 테스트. 
        - 둘 이상의 동작 단위를 검증할 때의 테스트.
        - 다른 팀이 개발한 모듈이 둘 이상 있을 때.

- End to end 테스트: end to end 테스트는 통합테스트의 일부이지만 일반적으로 구분해서 부른다. (일반적으로 구분해서 부르지만 뚜렷한 경계는 없음.)
    - 프로세스 외부 종속성과 함께 어떻게 작동하는지 검증
    - 일반적으로 end to end 테스트가 통합테스트보다 의존성을 더 많이 포함한다.
      - 통합테스트: 프로세스 외부 의존성을 한두 개만 갖고 작동
      - end to end 테스트: 프로세스 외부 의존성을 전부 또는 대다수 갖고 작동. 모든 외부 애플리케이션을 포함해 시스템을 최종 사용자 관점에서 검증.
    - (ex) 애플리케이션이 데이터베이스, 파일시스템, 외부 API와 연결할 때,
      - 통합테스트: 데이터베이스, 파일시스템만 포함, 외부 API는 test double로 처리
      - end to end 테스트: 전부 다 연결.
