초반 코드 설계의 중요성
=================

## 코드는 처음 설계가 중요하다
![KakaoTalk_Photo_2024-03-14-17-36-29.jpeg](image%2FKakaoTalk_Photo_2024-03-14-17-36-29.jpeg)

좋은 테스트를 포함하여 처음 설계된 코드는 처음 작업 소요 시간은 기나 개발 완료 후 유지보수 면에서 훨씬 안정적인 개발이 가능하다.

* 22년 엔진 설계 당시 코드 테스트 관리 방안
    * springBootTest 활용
    * 테스트 범위
      * ScenarioProcessServiceTest.class
        * 각 노드의 샘플 시나리오를 생성하여 노드 단위 테스트
        * 노드 샘플을 연결하여 N 턴의 테스트
 	private EngineReply getBasicNodeSample() {
>		EngineReply node = new EngineReply();
>
>		node.setId(6001L);
>		node.setNodeType(ChatNodeType.BASIC);
>		node.setChipList(null);
>		node.setNext(null);
>
>		EngineReplyMessage message = new EngineReplyMessage();
>		node.getMessages().add(message);
>		message.getMessages()
>			.add("'#{USER:selectedIntent:NONE}' 업무 처리에 대해 '#{USER:intentSelectionConfirm:NONE}'을/를 선택했습니다. 대화를 종료합니다.");
>
>		return node;


* 테스트의 한계
  * 실제 저작으로 발생할 수 있는 노드와 사용되는 파라미터의 가짓수는 매우 많음
    * 노드 내 세부 설정, 입력되는 발화, 노드 실행 시 컨텍스트 상태 등등..
    > 커버리지 지표: 테스트 스위트가 소스 코드를 얼마나 실행하는지의 백분율
    * 엔진 테스트는 커버리지 지표 자체는 높일 수 있으나 실제 서비스단의 테스트는 완전히 커버하기 힘듦
    * <b>100% 커버리지 = 좋은 테스트가 아니다.</b>
  ![KakaoTalk_Photo_2024-03-14-18-02-34.jpeg](image%2FKakaoTalk_Photo_2024-03-14-18-02-34.jpeg)
실제 서비스에서도 무수히 많은 입력 값이 존재한다. ex) 멀티모달 화면 로딩 중 갑자기 화면을 끈다거나..

* 좋은 테스트를 위해선 해야할 작업
  * 개발 주기에 통합되어 있어야 함
  * 코드베이스에서 가장 중요한 부분만을 대상으로 함
    * 엔진에서는 ScenarioProcessService -> NodeRunningService 부분 및 엔진 응답 생성 부분
  * 최소한의 유지비로 최대의 가치를 끌어내림
    * 비즈니스 로직 테스트를 위주로 진행해야 함

## 초기 개발시 스타일 통일의 중요성

  * 채널GW의 초기 설계 테스트 문제

채널GW는 기능 제공을 내부 챗화면(시뮬레이터)/외부 챗화면/보이스GW 3곳과 연계를 진행함.

초기 개발 시 챗봇은 시뮬레이터 위주로 테스트가 진행 되었기 때문에 기능 테스트가 많이 이루어짐.

보이스 GW와의 연동은 서비스 적용때까지 테스트가 한 번도 진행되지 않음..

보이스 연동 테스트를 신한 개발 서버에 처음 적용했을 때 당일에서야 해볼 수 있었음..

현재 신한에서 운영중인 봇은 대부분이 보이스봇. 보이스봇의 경우 연결 되어 있는 서비스(C-HUB, 보이스GW, 콜게이트 등등)
가 많아 로컬 테스트가 불가능한 상태로 배포가 되는 경우가 많음.

이런 환경이 발생한 원인

* 채널GW, 엔진의 개발 주체가 다름
* 채널GW <-> 엔진 간 비즈니스 로직 테스트 진행을 많이 하지 않음
  * 채널GW/엔진 초기 개발 당시 테스트 코드는 엔진의 내부 로직만 대부분을 차지.
* 채널GW의 각 플랫폼의 요청/응답 규격을 공통화 하지 않음

## 전체 시나리오 테스트에 적용할 수 있는 테스트 방안

* 고전파 테스트와 런던파 테스트의 차이
  * 고전파
    * 단위 테스트를 격리된 방식으로 진행한다.
    * 테스트가 서로 소통하고 실행 컨텍스트에 영향을 줄 수 있다.
    * 데이터베이스, 파일 시스템 등 외부 의존성에 영향을 받는다.
    * 고품질의 테스트를 만들고 프로젝트의 지속 가능한 성장을 달성하는데 적합함.
  ![KakaoTalk_Photo_2024-03-18-16-27-51 001.jpeg](image%2FKakaoTalk_Photo_2024-03-18-16-27-51%20001.jpeg)

  * 런던파
    * 테스트 대상 시스템에서 협력자(공유 의존성 객체)를 분리한다.
    * 한 번에 한 클래스만 테스트한다.
    * 서로 연결된 클래스의 규모가 커져도 테스트 하기 쉽다.
    * 테스트가 실패 했을 때 어떤 기능이 실패했는지 확인이 쉽다.

> 공유 의존성, Shared dependency
공유 의존성은 테스트 간에 공유되고 서로의 결과에 영향을 미칠 수 있는 수단을 제공하는 의존성.
전형적인 예는 정적 가변 필드로 동일한 프로세스 내에서 실행되는 모든 단위 테스트에서 볼 수 있다.

> 비공개 의존성, Private dependency
공유하지 않는 의존성

> 프로세스 외부 의존성, out-of-process dependency
애플리케이션 실행 프로세스 외부에서 실행되는 의존성이며, 아직 메모리에 없는 데이터에 대한 프록시다.
프로세스 외부 의존성은 대부분 공유 의존성에 해당하지만 모두 그런 것은 아니다.
데이터베이스는 프로세스 외부 의존성이면서 공유 의존성이지만, 각 테스트 실행 전에 도커 컨테이너로 데이터베이스를 시작하면 테스트가 더 이상 동일한 인스턴스로 작동하지 않기 때문에 프로세스 외부이면서 비공개 의존성이 된다. 실제 프로젝트에서는 프로세스 외부 의존성가 아닌 공유 의존성은 거의 없다.

![KakaoTalk_Photo_2024-03-18-16-27-58.jpeg](image%2FKakaoTalk_Photo_2024-03-18-16-27-58.jpeg)

  ![KakaoTalk_Photo_2024-03-18-16-27-51 002.jpeg](image%2FKakaoTalk_Photo_2024-03-18-16-27-51%20002.jpeg)

  * 기능 테스트에는 고전파가 더 좋다?
    * 격리 문제를 주로 논의하고 있는데, 이 논쟁으로 고전파(디트로이트)와 런던파(목 추종자)라는 두 개의 단위 테스트 분파로 나뉘었다. 이러한 의견 차이는 무엇이 단위를 의미하는지에 대한 관점과 테스트 대상 시스템(SUT)의 의존성 처리 방식에 영향을 미친다.
      * 런던파는 테스트 대상 단위를 서로 분리해야 한다고 한다. 테스트 대상 단위는 코드의 단위, 보통 단일 클래스다. 불변 의존성을 제외한 모든 의존성을 테스트 대역으로 대체해야 한다.
      * 고전파는 단위가 아니라 단위 테스트를 서로 분리해야 한다고 한다. 또한 테스트 대상 단위는 코드 단위가 아니라 동작 단위다. 따라서 공유 의존성만 테스트 대역응로 대체해야 한다. 공유 의존성은 테스트가 서로 실행 흐름에 영향을 미치는 수단을 제공하는 의존성이다.
      * 런던파는 더 나은 입자성의 이점, 상호 연결된 클래스의 큰 그래프에 대한 테스트 용이성 그리고 테스트 실패 후 버그가 있는 기능을 쉽게 찾을 수 있는 편의성 등을 제공한다.
      * 런던파의 장점이 처음에는 매력적으로 보인다. 그런다 몇 가지 문제가 있다. 먼저 테스트 대상 클래스에 대한 초점이 잘못됐다. 테스트는 코드 단위가 아니라 동작 단위를 검증해야 한다. 더욱이 코드 조각을 단위 테스트할 수 없다는 것은 코드 설계에 문제가 있다는 것을 알려주는 강한 징후다. 테스트 대역을 사용한다고 해도 이 문제를 해결하는 게 아니라 오히려 숨길 뿐이다. 마지막으로 테스트 실패 후 어떤 기능에 버그가 있는지 판단하는 것이 도움은 되지만, 종종 버그의 원인을 알고 있기 때문에 그리 큰 문제는 아니다. 즉, 바로 마지막에 수정한 것이 버그의 원인일 것이다.


* AIBOT에 적용할 테스트 방법
  * AIBOT 기능은 대부분이 엔드 투 엔드 테스트
  * 엔진 내 모든 노드는 싱글턴 컴포넌트지만 중요한 context 메모리는 쓰레드 별로 다르므로 비공개 의존성을 지님.
  * 각 노드 기능은 클래스 별 테스트로 진행 하되 전체 테스트는 통합 테스트로 진행
![KakaoTalk_Photo_2024-03-18-18-09-42.jpeg](image%2FKakaoTalk_Photo_2024-03-18-18-09-42.jpeg)
  * vs 시뮬레이터 테스트
    * 시뮬레이터 테스트가 코드 테스트를 전부 커버 가능한가?
    * 시뮬레이터 -> 채널GW -> 엔진의 로직은 전부 동일
    * 신한에서 사용하는 시나리오와 고객의 발화를 규격화 할 수 있나?
      * 한 시나리오에 몇십개가 들어가는 노드는 규격화 하기 어렵다..

* 단위 테스트를 얼마나 나눠야 하는가(feat. 멀티모달)
  * 테스트는 해결하는 데 도움이 되는 문제를 하나로 묶어야 한다.
  ex) 우리집 강아지를 부르면, 바로 나에게 온다. -> 우리집 강아지를 부르면 왼쪽 앞다리를 움직이고, 머리를 돌리고, 꼬리를 흔들고..
  * 클래스 그래프를 설계때 부터 작게 만들어야 한다.
  * 멀티모달의 테스트 작성 방안
    * 멀티모달에 연관된 외부 시스템
      * redis / 콜게이트 / 사용자 폰 / 보이스GW .. 매우 많은 연관 관계가 존재
      * 멀티모달에서의 단위 테스트는 멀티모달 화면 -> 채널GW -> 엔진의 시나리오 결과가 각 API 호출 시 결과를 테스트 하는 것
      * 콜게이트의 데이터와 사용자 폰의 동작은 로컬에서 더미를 사용할 수 밖에 없음.
        * 테스트 클래스에서 콜게이트 결과를 임의로 생성하는 준비 로직의 생성이 필요
        * 콜게이트의 정보는 목으로 대체가 가능할까?
          * 콜게이트의 결과에서 중요한 데이터는 핸드폰의 종류/인앱 여부로 인한 시나리오 분기 처리이므로 대체가 가능하다.
        * 사용자의 클릭은 목으로 대체가 가능할까?
          * 발생했던 이슈
            * 사용자가 SMS의 클릭을 늦게하는 동안 url이 타이밍 맞게 만료가 되서 페이지 로딩이 되지 않음.
            * 이런 이슈를 의도적으로 재연이 가능한가?
  * AAA 패턴
      > AAA 패턴이란? 하나의 테스트를 할 기능을 메소드로 하여 준비(Arrange)/실행(Act)/검증(Assert) 3단계로 나누는 패턴
     * AAA 패턴의 실행 코드는 한 줄로 작성 되어야 한다. 테스트에는 if 문 등의 분기가 없어야 하고 유지보수가 늘어난다.
  * 테스트 픽스쳐
    * 테스트 실행 대상 객체. 엔진의 경우 각 노드.
    * 비슷한 테스트의 팩트는 매개변수화 해서 묶을 수 있다.
![img.png](image%2Fimg.png)



